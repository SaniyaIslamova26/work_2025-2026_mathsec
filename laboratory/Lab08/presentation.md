---
## Front matter
lang: ru-RU
title: Лабораторная работа №8
subtitle:  Целочисленная арифметика многократной точности
author: Исламова С.М.
  - 
  
institute:
  - Российский университет дружбы народов, Москва, Россия
date:
- 18.12.2025

## i18n babel
babel-lang: russian
babel-otherlangs: english

## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9

## Formatting pdf
toc: false
toc-title: Содержание
slide_level: 2
aspectratio: 169
section-titles: true
theme: metropolis
header-includes:
 - \metroset{progressbar=frametitle,sectionpage=progressbar,numbering=fraction}
 - '\makeatletter'
 - '\beamer@ignorenonframefalse'
 - '\makeatother'
---

# Информация

## Докладчик

:::::::::::::: {.columns align=center}
::: {.column width="70%"}

  * Исламова Сания Маратовна
  * студент уч. группы НПИмд-01-24
  * Российский университет дружбы народов
  * [1132249576@pfur.ru](mailto:1132249576@pfur.ru)
  * <https://github.com/SaniyaIslamova26>

:::
::: {.column width="30%"}

<img width="341" height="347" alt="1" src="https://github.com/user-attachments/assets/b729e53a-3167-4c53-806e-976217c478d6" />

:::
::::::::::::::

# Вводная часть
### Актуальность
- Работа с целыми числами произвольной длины (больше, чем поддерживают стандартные типы)
- Реализация базовых арифметических операций без использования встроенных больших чисел
- Понимание низкоуровневых алгоритмов сложения, вычитания, умножения и деления в столбик
- Изучение представления чисел в системах счисления с произвольным основанием b ≥ 2
- Применение полученных навыков в криптографии, компьютерной алгебре и обработке больших данных

### Объект и предмет исследования
- Алгоритмы арифметики многократной точности в системах счисления с основанием b
- Представление больших целых чисел в виде массивов цифр (разрядов)
- Классические школьные алгоритмы сложения, вычитания, умножения и деления в столбик
- Сравнение двух вариантов алгоритма умножения (обычный и "быстрый" столбик)
- Деление многоразрядных чисел с остатком (аналог длинного деления)

### Цели и задачи
- Реализовать пять алгоритмов арифметических операций с большими целыми числами в основании b
- Обеспечить корректную работу с числами произвольной разрядности
- Исследовать поведение алгоритмов на различных входных данных и основаниях счисления
- Сравнить эффективность обычного и "быстрого" умножения столбиком
- Проверить корректность реализации на тестовых примерах
- Организовать удобный интерактивный ввод-вывод с возможностью многократного выполнения операций

## Теоретическая часть

### Представление больших целых чисел
Большое натуральное n-разрядное число в системе счисления с основанием b представляется в виде последовательности цифр:
\[
u = u_1 u_2 \dots u_n, \quad 0 \leq u_i < b
\]
где индекс 1 соответствует младшему разряду. Знак числа хранится отдельно (в данной работе рассматриваются только неотрицательные числа).

### Алгоритм 1. Сложение неотрицательных целых чисел
Вход: два неотрицательных числа одинаковой разрядности n в основании b.  
Выход: сумма w = w₀ w₁ … wₙ, где w₀ — цифра переноса (0 или 1).  
Итеративно по разрядам от младшего к старшему вычисляется сумма цифр с учётом переноса:
\[
w_j = (u_j + v_j + k) \mod b, \quad k = \left\lfloor \frac{u_j + v_j + k}{b} \right\rfloor
\]

### Алгоритм 2. Вычитание неотрицательных целых чисел (u ≥ v)
Вход: u > v, разрядность n, основание b.  
Выход: разность w = u − v.  
Аналогично сложению, но с учётом займа:
\[
w_j = (u_j - v_j + k) \mod b, \quad k = \left\lfloor \frac{u_j - v_j + k}{b} \right\rfloor
\]
(с корректировкой при отрицательном результате).

### Алгоритм 3. Умножение неотрицательных целых чисел столбиком
Классический школьный алгоритм: каждый разряд второго множителя умножается на всё первое число, результат сдвигается и прибавляется к накопленному произведению.  
Сложность: O(n·m), где n и m — разрядности чисел.

### Алгоритм 4. Быстрый столбик
Альтернативная реализация умножения: суммирование произведений цифр по диагоналям промежуточного "столбика".  
Даёт тот же результат, но с другой организацией вычислений (удобно для параллелизации и анализа).

### Алгоритм 5. Деление многоразрядных целых чисел
Длинное деление в столбик:
- Оценка каждой цифры частного по старшим разрядам
- Корректировка оценки (не более чем на 1)
- Вычитание произведения цифры частного на делитель
- Обработка возможного переполнения и коррекция
Выход: частное q и остаток r (deg r < deg v).

### Особенности реализации на языке Julia
1. Представление чисел как Vector{Int} (индекс 1 — младший разряд)
2. Ручная реализация всех операций без использования BigInt (кроме ввода-вывода для удобства)
3. Поддержка оснований b от 2 до 36 (с буквенными цифрами A–Z)
4. Функции преобразования строки ↔ массив цифр с проверкой допустимости
5. Удаление ведущих нулей для корректного отображения
6. Интерактивное меню с возможностью многократного выполнения и выхода

# Практическая реализация
Реализованы на языке программирования Julia все пять алгоритмов арифметики многократной точности в соответствии с описанием в лабораторной работе:
- Алгоритм 1 — сложение
- Алгоритм 2 — вычитание (с проверкой u ≥ v)
- Алгоритм 3 — умножение классическим столбиком
- Алгоритм 4 — умножение быстрым столбиком
- Алгоритм 5 — деление с остатком

:::::::::::::: {.columns align=top}
::: {.column}

```Julia
# Функция преобразования массива цифр в строку в системе счисления b
function digits_to_str(dig::Vector{Int}, b::Int)::String
    # Если массив пустой или состоит только из нулей — число равно 0
    if isempty(dig) || all(==(0), dig)
        return "0"
    end
    # Собираем строку из цифр, начиная со старшего разряда (reverse)
    # Если цифра ≥10, преобразуем в букву A–Z (для оснований >10)
    join([d < 10 ? string(d) : string(Char('A' + d - 10)) for d in reverse(dig)], "")
    # Результат: строка, представляющая число в основании b, без ведущих нулей
end

# Функция преобразования строки в массив цифр (младший разряд — индекс 1)
function str_to_digits(s::String, b::Int)::Vector{Int}
    # Убираем пробелы и приводим к нижнему регистру для удобства
    s = strip(lowercase(s))
    # Пустая строка или "0" → представляем как [0]
    if s == "" || s == "0" return [0] end
    digits = Int[]  # Создаём пустой массив для цифр
    # Проходим по символам строки справа налево (младшие разряды первые)
    for c in reverse(s)
        # Преобразуем символ в цифру: 0–9 или A–Z → 10–35
        d = isdigit(c) ? c - '0' : (uppercase(c) - 'A' + 10)
        # Проверяем, что цифра допустима в данном основании
        if d < 0 || d >= b
            error("Недопустимая цифра '$c' в основании $b")
        end
        push!(digits, d)  # Добавляем цифру в массив (младшая первая)
    end
    # Удаляем ведущие нули (кроме случая, когда число 0)
    while length(digits) > 1 && digits[end] == 0
        pop!(digits)
    end
    digits  # Результат: массив цифр, младший разряд — digits[1]
end

# Удаление ведущих нулей из массива цифр
function trim(dig::Vector{Int})::Vector{Int}
    # Пока больше одного разряда и старший разряд нулевой — удаляем его
    while length(dig) > 1 && dig[end] == 0
        pop!(dig)
    end
    dig  # Результат: массив без ведущих нулей (кроме [0] для нуля)
end

# Алгоритм 1: Сложение неотрицательных чисел (по лабораторной)
function add_big(u::Vector{Int}, v::Vector{Int}, b::Int)::Vector{Int}
    n = max(length(u), length(v))  # Определяем максимальную разрядность
    w = zeros(Int, n + 1)         # Результирующий массив на один разряд больше (для переноса)
    k = 0                         # Перенос, изначально 0
    for j = 1:n                   # Проходим по разрядам от младшего к старшему
        uj = j <= length(u) ? u[j] : 0  # Берем цифру из u или 0, если разряд кончился
        vj = j <= length(v) ? v[j] : 0  # Аналогично для v
        s = uj + vj + k            # Сумма цифр + перенос
        w[j] = s % b              # Записываем младшую часть суммы в текущий разряд
        k = s ÷ b                 # Новый перенос в старший разряд
    end
    w[n+1] = k                    # Записываем финальный перенос (w₀ в алгоритме)
    trim(w)                       # Убираем ведущие нули
    # Результат: сумма u + v в основании b
end

# Алгоритм 2: Вычитание u - v (u ≥ v ≥ 0)
function sub_big(u::Vector{Int}, v::Vector{Int}, b::Int)::Vector{Int}
    n = length(u)                 # Разрядность берём по первому числу (u ≥ v)
    w = zeros(Int, n)             # Результирующий массив
    k = 0                         # Заём из старшего разряда, изначально 0
    for j = 1:n
        uj = u[j]                 # Цифра из уменьшаемого
        vj = j <= length(v) ? v[j] : 0  # Цифра из вычитаемого или 0
        s = uj - vj - k            # Разность с учётом займа
        if s < 0                  # Если получилась отрицательная цифра
            s += b                # Занимаем из старшего разряда (добавляем основание)
            k = 1                 # Устанавливаем заём для следующего разряда
        else
            k = 0                 # Заём не нужен
        end
        w[j] = s                  # Записываем цифру результата
    end
    trim(w)                       # Убираем ведущие нули
    # Результат: разность u - v в основании b
end

# Алгоритм 3: Умножение "столбиком"
function mul_classic(u::Vector{Int}, v::Vector{Int}, b::Int)::Vector{Int}
    n, m = length(u), length(v)   # Разрядности множимого и множителя
    w = zeros(Int, n + m)         # Результат до n+m разрядов
    for j = 1:m                   # По разрядам множителя v (от младшего)
        v[j] == 0 && continue     # Если цифра 0 — пропускаем (оптимизация)
        k = 0                     # Перенос для текущего "столбика"
        for i = 1:n               # По разрядам множимого u
            t = u[i] * v[j] + w[i+j-1] + k  # Произведение + уже накопленное + перенос
            w[i+j-1] = t % b      # Записываем в текущий разряд
            k = t ÷ b             # Перенос в следующий разряд
        end
        w[n+j] = k                # Записываем оставшийся перенос
    end
    trim(w)                       # Убираем ведущие нули
    # Результат: произведение u × v в основании b
end

# Алгоритм 4: Умножение "быстрым столбиком"
function mul_fast(u::Vector{Int}, v::Vector{Int}, b::Int)::Vector{Int}
    n, m = length(u), length(v)
    w = zeros(Int, n + m)         # Результат до n+m разрядов
    t = 0                         # Накопитель промежуточной суммы
    for s = 0:n+m-2               # s — диагональ в "столбике"
        low = max(0, s - m + 1)   # Нижняя граница индекса i
        high = min(s, n - 1)      # Верхняя граница индекса i
        for i = low:high          # Суммируем все произведения на этой диагонали
            t += u[i+1] * v[s-i+1]
        end
        w[n+m-s-1] = t % b         # Записываем цифру в соответствующий разряд
        t ÷= b                    # Переносим остаток в следующую диагональ
    end
    w[1] = t                      # Последний перенос в старший разряд
    trim(w)
    # Результат: произведение u × v (тот же, что и в mul_classic, но другой алгоритм)
end

# Алгоритм 5: Деление с остатком
function div_big(u_::Vector{Int}, v_::Vector{Int}, b::Int)
    u = copy(u_)                  # Копируем, чтобы не изменять оригинал
    v = trim(copy(v_))            # Копируем и убираем ведущие нули у делителя
    n, t = length(u), length(v)   # Разрядности делимого и делителя
    if t == 0 || all(==(0), v)     # Проверка деления на ноль
        error("Деление на ноль")
    end
    q = zeros(Int, n - t + 1)     # Массив для частного (максимальная длина)
    for i = n:-1:t+1              # По разрядам делимого от старшего
        hi = i <= n ? u[i] : 0    # Текущий старший разряд
        mi = i-1 >= 1 ? u[i-1] : 0 # Следующий разряд
        lo = i-2 >= 1 ? u[i-2] : 0 # Ещё один для точной оценки
        # Оценка цифры частного
        qhat = hi >= v[t] ? b - 1 : (hi * b + mi) ÷ v[t]
        v1 = v[t] * b + (t >= 2 ? v[t-1] : 0)  # Для проверки переполнения
        # Корректируем оценку вниз, если слишком большая
        while qhat > 0 && qhat * v1 > hi * b*b + mi * b + lo
            qhat -= 1
        end
        borrow = 0                # Заём при вычитании
        for j = 1:t               # Вычитаем qhat × v × b^(i-t)
            pos = i - t + j
            if pos > length(u)    # Если нужно — расширяем массив u
                resize!(u, pos)
                u[pos] = 0
            end
            temp = qhat * v[j] + borrow
            u[pos] -= temp % b
            borrow = temp ÷ b
            if u[pos] < 0         # Если отрицательно — занимаем
                u[pos] += b
                borrow += 1
            end
        end
        pos_carry = i + 1
        if pos_carry <= length(u)
            u[pos_carry] -= borrow  # Вычитаем заём из старшего разряда
            if u[pos_carry] < 0    # Если переполнение — корректируем
                u[pos_carry] += b
                qhat -= 1
            end
        end
        q[i - t] = qhat           # Записываем цифру частного
    end
    r = length(u) >= t ? u[1:t] : u  # Остаток — младшие t разрядов
    trim(q), trim(r)              # Убираем ведущие нули
    # Результат: кортеж (частное, остаток)
end


println("Лабораторная работа №8: Арифметика многократной точности")
println("0 — Выход")
println("1 — Сложение")
println("2 — Вычитание")
println("3 — Умножение столбиком")
println("4 — Умножение быстрым столбиком")
println("5 — Деление с остатком\n")

# Бесконечный цикл — программа работает, пока пользователь не выберет выход
while true
    print("Выберите алгоритм (0 для выхода): ")
    input = strip(readline())                 # Считываем и убираем лишние пробелы
    input == "0" && (println("До свидания!"); break)  # Выход по 0
    
    # Преобразуем ввод в число, если ошибка — сообщаем и продолжаем цикл
    alg = try parse(Int, input) catch
        println("Неверный выбор\n"); continue
    end
    if !(1 <= alg <= 5)                       # Проверяем диапазон
        println("Выберите от 1 до 5\n"); continue
    end

    print("Основание b (2–36): ")
    b = try parse(Int, readline()) catch      # Считываем основание
        println("Неверное основание\n"); continue
    end
    if !(2 <= b <= 36)                        # Проверяем допустимость
        println("b должно быть от 2 до 36\n"); continue
    end

    print("Первое число (в системе $b): ")
    s1 = readline()                           # Ввод первого числа как строки
    print("Второе число (в системе $b): ")
    s2 = readline()                           # Ввод второго числа

    try
        # Преобразуем строки в массивы цифр
        u = str_to_digits(s1, b)
        v = str_to_digits(s2, b)

        # Выполняем выбранный алгоритм
        if alg == 1
            res = add_big(u, v, b)
            println("Сумма: $(digits_to_str(res, b))\n")
        elseif alg == 2
            # Проверка условия u ≥ v для вычитания
            if length(u) < length(v) || (length(u) == length(v) && u < v)
                println("Ошибка: первое число должно быть ≥ второго\n")
            else
                res = sub_big(u, v, b)
                println("Разность: $(digits_to_str(res, b))\n")
            end
        elseif alg == 3
            res = mul_classic(u, v, b)
            println("Произведение (столбиком): $(digits_to_str(res, b))\n")
        elseif alg == 4
            res = mul_fast(u, v, b)
            println("Произведение (быстро): $(digits_to_str(res, b))\n")
        elseif alg == 5
            q, r = div_big(u, v, b)
            println("Частное: $(digits_to_str(q, b))")
            println("Остаток: $(digits_to_str(r, b))\n")
        end
    catch e
        # Ловим все ошибки ввода (недопустимые цифры и т.д.)
        println("Ошибка: $(sprint(showerror, e))\n")
    end
end
```

### Программа обеспечивает:
- Ввод основания b (2–36)
- Ввод двух чисел в выбранной системе счисления
- Выбор операции из меню
- Корректный вывод результата в той же системе счисления
- Возможность повторного выполнения операций (цикл с выходом по 0)

:::
::: {.column width="25%"}

<img width="792" height="948" alt="Снимок экрана 2025-12-18 124037" src="https://github.com/user-attachments/assets/11acaf44-e001-4f21-b726-ee9ba5629c6b" />

:::
::: {.column width="25%"}

<img width="860" height="950" alt="Снимок экрана 2025-12-18 124053" src="https://github.com/user-attachments/assets/9870c42c-f1dc-424f-97a7-3c60fbd9addd" />

:::
::: {.column width="25%"}

<img width="798" height="785" alt="Снимок экрана 2025-12-18 124109" src="https://github.com/user-attachments/assets/67e6561a-f0e5-4480-8fa1-450d2c82fa15" />

:::
::: {.column width="25%"}

<img width="798" height="952" alt="Снимок экрана 2025-12-18 124120" src="https://github.com/user-attachments/assets/848913a5-f007-42fc-9598-8edc0bd14bd2" />

:::
::: {.column width="25%"}

<img width="814" height="927" alt="Снимок экрана 2025-12-18 124134" src="https://github.com/user-attachments/assets/fb6208fb-5c46-4fff-8719-98c92edb4708" />

:::
::: {.column width="25%"}

<img width="715" height="745" alt="Снимок экрана 2025-12-18 124145" src="https://github.com/user-attachments/assets/08ed74fc-7519-4dca-a4d2-f0fc7f0ba9da" />

:::
::: {.column width="25%"}

<img width="583" height="922" alt="Снимок экрана 2025-12-18 124015" src="https://github.com/user-attachments/assets/c16a5a2c-f9d2-450b-8e55-99a459a2c17d" />

:::
::::::::::::::


# Результаты
- Успешно реализованы все пять требуемых алгоритмов
- Программа корректно обрабатывает числа произвольной длины
- Поддерживается работа в системах счисления до основания 36
- Проведено тестирование на различных примерах (включая переносы, займы, большие разрядности)
- Оба алгоритма умножения дают идентичные результаты
- Деление корректно выдаёт частное и остаток

## Вывод
В рамках лабораторной работы №8 успешно реализованы на языке программирования Julia алгоритмы целочисленной арифметики многократной точности в произвольной системе счисления: сложение, вычитание, два варианта умножения и деление с остатком. Реализация полностью соответствует описанным в задании алгоритмам, обеспечивает корректную работу с большими числами и удобный интерактивный интерфейс.
