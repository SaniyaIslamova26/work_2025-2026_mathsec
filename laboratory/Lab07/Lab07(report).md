# Лабораторная работа №7

Тема: Дискретное логарифмирование в конечном поле

Выполнила: Исламова Сания Маратовна

Группа: НПИмд-01-24

Студ.билет: 1132249576

### Задача лабораторной работы:

 Реализовать рассмотренный алгоритм программно: Алгоритм, реализующий  p-метод Полларда для задач дискретного логарифмирования

### Описание хода выполнения лабораторной работы:

```Julia
# Заголовок программы
println("ρ-метод Полларда для дискретного логарифмирования")
# Бесконечный цикл для многократного использования программы
while true
    # Запрос ввода данных от пользователя
    println("\nВведите p a b r через пробел (или 'выход' для завершения):")
    # Чтение введенной строки с клавиатуры
    input = readline()
    # Проверка команды выхода из программы
    input == "выход" && break
    # Блок обработки ошибок ввода
    try
        # Разделение строки на части и преобразование в BigInt
        p,a,b,r = parse.(BigInt, split(input))
        # Определение функции ρ-метода Полларда
        function ρ(p,a,b,r)
            # Инициализация: случайные u, v из [0, r-1]
            u,v = rand(0:r-1,2)
            # Вычисление начальной точки c = a^u * b^v mod p
            c = powermod(a,u,p)*powermod(b,v,p)%p
            # Черепаха и заяц: начальные точки одинаковы
            d = c 
            # Инициализация логарифмов: log(c) = u + v*x, log(d) = u + v*x
            α1,β1,α2,β2 = u,v,u,v
            # Цикл поиска коллизии (метод Флойда)
            while (c = (c<p÷2 ? a*c : b*c)%p) != 
                  # Обновление d (два шага)
                  (d = (d<p÷2 ? a*d : b*d)%p; d = (d<p÷2 ? a*d : b*d)%p)
                # Обновление логарифмов для c (один шаг)
                α1,β1 = (α1+(c<p÷2))%r, (β1+(c≥p÷2))%r 
                # Обновление логарифмов для d (два шага)
                α2,β2 = (α2+2(d<p÷2))%r, (β2+2(d≥p÷2))%r
            end
            # После нахождения коллизии: решение уравнения
            # Находим коэффициенты (β1-β2)*x ≡ (α2-α1) (mod r)
            g,x,_ = gcdx((β1-β2)%r, r)
            # Проверка разрешимости и возврат решения
            (Δα=(α2-α1)%r)%g ≠ 0 ? nothing : (x*Δα÷g)%r
        end
        # Вызов функции и получение результата
        x = ρ(p,a,b,r)
        # Вывод результата
        println(x===nothing ? "Нет решений" : "x = $x")
    # Обработка ошибок при некорректном вводе
    catch
        println("Ошибка: введите 4 числа или 'выход'")
    end
end
# Сообщение о завершении программы
println("Программа завершена")
```

### Результат реализации рассмотренного алгоритма 

<img width="632" height="852" alt="Снимок экрана 2025-12-02 115242" src="https://github.com/user-attachments/assets/06c31cff-3e25-445a-a361-10863ab3d2df" />

<img width="688" height="387" alt="Снимок экрана 2025-12-02 115112" src="https://github.com/user-attachments/assets/871d7975-407a-4da5-bde2-55c01ff05a59" />



