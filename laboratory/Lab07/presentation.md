---
## Front matter
lang: ru-RU
title: Лабораторная работа №7
subtitle:  Дискретное логарифмирование в конечном поле. Метод Полларда
author: Исламова С.М.
  - 
  
institute:
  - Российский университет дружбы народов, Москва, Россия
date:
- 02.12.2025

## i18n babel
babel-lang: russian
babel-otherlangs: english

## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9

## Formatting pdf
toc: false
toc-title: Содержание
slide_level: 2
aspectratio: 169
section-titles: true
theme: metropolis
header-includes:
 - \metroset{progressbar=frametitle,sectionpage=progressbar,numbering=fraction}
 - '\makeatletter'
 - '\beamer@ignorenonframefalse'
 - '\makeatother'
---

# Информация

## Докладчик

:::::::::::::: {.columns align=center}
::: {.column width="70%"}

  * Исламова Сания Маратовна
  * студент уч. группы НПИмд-01-24
  * Российский университет дружбы народов
  * [1132249576@pfur.ru](mailto:1132249576@pfur.ru)
  * <https://github.com/SaniyaIslamova26>

:::
::: {.column width="30%"}

<img width="341" height="347" alt="1" src="https://github.com/user-attachments/assets/b729e53a-3167-4c53-806e-976217c478d6" />

:::
::::::::::::::

# Вводная часть
### Актуальность

- Реализация ρ-метода Полларда для дискретного логарифмирования
- Работа с большими числами в языке Julia
- Понимание вероятностных методов в криптографии
- Изучение задач, лежащих в основе современных криптографических систем
- Анализ сложности решения задачи дискретного логарифмирования

### Объект и предмет исследования

- ρ-метод Полларда для дискретного логарифмирования
- Задача дискретного логарифмирования в конечных полях
- Конечные поля и их алгебраические свойства
- Метод "черепахи и зайца" для поиска коллизий
- Язык программирования Julia для реализации криптографических алгоритмов

### Цели и задачи

- Реализовать ρ-метод Полларда для решения задачи дискретного логарифмирования
- Исследовать эффективность метода на различных входных данных
- Проанализировать поведение алгоритма в зависимости от параметров поля
- Изучить математические основы метода и его криптографическое значение
- Проверить корректность реализации на тестовых примерах

## Теоретическая часть

### Задача дискретного логарифмирования (Discrete Logarithm Problem, DLP)

Для заданных простого числа \( p \), основания \( a \) (образующего элемента мультипликативной группы \( \mathbb{F}_p^* \)) и числа \( b \) требуется найти целое число \( x \) такое, что:

\[
a^x \equiv b \ (\text{mod} \ p)
\]

где \( 1 < a < p \), \( 1 < b < p \).

### Математические основы

#### Конечные поля
Множество классов вычетов по модулю простого числа \( p \) образует конечное поле \( \mathbb{F}_p = \mathbb{Z}/p\mathbb{Z} \), которое обладает следующими свойствами:
- Сложение и умножение определены по модулю \( p \)
- Существует мультипликативная группа \( \mathbb{F}_p^* \) порядка \( p-1 \)
- Каждый ненулевой элемент имеет обратный по умножению

#### Отношение сравнимости
Для целых чисел \( a, b \) и модуля \( m > 1 \):
\[
a \equiv b \ (\text{mod} \ m) \iff m \mid (a - b)
\]

Отношение сравнимости является отношением эквивалентности и разбивает множество целых чисел на \( m \) классов вычетов.

### ρ-Метод Полларда для дискретного логарифмирования

#### Основная идея
Метод основан на поиске коллизии в псевдослучайной последовательности, порождаемой итеративным применением специального отображения. При обнаружении коллизии (равенства двух элементов последовательности) возникает уравнение, из которого можно найти искомый логарифм.

#### Алгоритмические компоненты

1. **Ветвящееся отображение**:
   \[
   f(c) = 
   \begin{cases} 
   a \cdot c \ (\text{mod} \ p) & \text{при } c < p/2 \\
   b \cdot c \ (\text{mod} \ p) & \text{при } c \geq p/2
   \end{cases}
   \]

2. **Представление логарифмов**:
   Каждый элемент последовательности представляется в виде \( a^{\alpha} \cdot b^{\beta} \ (\text{mod} \ p) \), где логарифм вычисляется как линейная функция \( \alpha + \beta \cdot x \).

3. **Метод "черепахи и зайца" (Флойда)**:
   - Инициализация двух последовательностей с одинаковым начальным значением
   - Одна последовательность ("черепаха") делает по одному шагу на каждой итерации
   - Другая последовательность ("заяц") делает по два шага на каждой итерации
   - Когда эти последовательности встречаются, обнаружена коллизия

#### Математическое обоснование

Пусть:
- \( c_i = a^{\alpha_i} \cdot b^{\beta_i} \ (\text{mod} \ p) \)
- \( d_i = a^{\gamma_i} \cdot b^{\delta_i} \ (\text{mod} \ p) \)

При коллизии \( c_k = d_m \) имеем:
\[
a^{\alpha_k} \cdot b^{\beta_k} \equiv a^{\gamma_m} \cdot b^{\delta_m} \ (\text{mod} \ p)
\]

Подставляя \( b \equiv a^x \ (\text{mod} \ p) \), получаем:
\[
a^{\alpha_k + \beta_k x} \equiv a^{\gamma_m + \delta_m x} \ (\text{mod} \ p)
\]

Отсюда:
\[
\alpha_k + \beta_k x \equiv \gamma_m + \delta_m x \ (\text{mod} \ r)
\]
где \( r \) - порядок элемента \( a \).

Решая это линейное сравнение:
\[
(\beta_k - \delta_m)x \equiv (\gamma_m - \alpha_k) \ (\text{mod} \ r)
\]

#### Вычислительная сложность

- Среднее время работы: \( O(\sqrt{r}) \), где \( r \) - порядок элемента \( a \)
- Память: \( O(1) \) (алгоритм требует хранения только нескольких переменных)
- Вероятностный характер: гарантирует нахождение решения с высокой вероятностью

#### Криптографическое значение

- Задача дискретного логарифмирования является основой многих криптографических протоколов (Диффи-Хеллмана, Эль-Гамаля, цифровых подписей)
- Стойкость этих систем зависит от вычислительной сложности решения DLP
- ρ-метод Полларда является одним из наиболее эффективных алгоритмов общего назначения для решения DLP
- Понимание метода важно для оценки стойкости криптографических систем и разработки криптоаналитических инструментов

### Особенности реализации на языке Julia

1. **Типы данных**: Использование `BigInt` для работы с большими числами
2. **Модульная арифметика**: Функции `mod()` и `powermod()` для эффективных вычислений
3. **Алгоритмы теории чисел**: Функция `gcdx()` для реализации расширенного алгоритма Евклида
4. **Генерация случайных чисел**: Функция `rand()` для инициализации параметров алгоритма

# Практическая реализация
## Реализация на языке программирования Julia разложение чисел на множители: ρ-алгоритма Полларда для разложения чисел на множители

:::::::::::::: {.columns align=top}
::: {.column}

```Julia
# Заголовок программы
println("ρ-метод Полларда для дискретного логарифмирования")
# Бесконечный цикл для многократного использования программы
while true
    # Запрос ввода данных от пользователя
    println("\nВведите p a b r через пробел (или 'выход' для завершения):")
    # Чтение введенной строки с клавиатуры
    input = readline()
    # Проверка команды выхода из программы
    input == "выход" && break
    # Блок обработки ошибок ввода
    try
        # Разделение строки на части и преобразование в BigInt
        p,a,b,r = parse.(BigInt, split(input))
        # Определение функции ρ-метода Полларда
        function ρ(p,a,b,r)
            # Инициализация: случайные u, v из [0, r-1]
            u,v = rand(0:r-1,2)
            # Вычисление начальной точки c = a^u * b^v mod p
            c = powermod(a,u,p)*powermod(b,v,p)%p
            # Черепаха и заяц: начальные точки одинаковы
            d = c 
            # Инициализация логарифмов: log(c) = u + v*x, log(d) = u + v*x
            α1,β1,α2,β2 = u,v,u,v
            # Цикл поиска коллизии (метод Флойда)
            while (c = (c<p÷2 ? a*c : b*c)%p) != 
                  # Обновление d (два шага)
                  (d = (d<p÷2 ? a*d : b*d)%p; d = (d<p÷2 ? a*d : b*d)%p)
                # Обновление логарифмов для c (один шаг)
                α1,β1 = (α1+(c<p÷2))%r, (β1+(c≥p÷2))%r 
                # Обновление логарифмов для d (два шага)
                α2,β2 = (α2+2(d<p÷2))%r, (β2+2(d≥p÷2))%r
            end
            # После нахождения коллизии: решение уравнения
            # Находим коэффициенты (β1-β2)*x ≡ (α2-α1) (mod r)
            g,x,_ = gcdx((β1-β2)%r, r)
            # Проверка разрешимости и возврат решения
            (Δα=(α2-α1)%r)%g ≠ 0 ? nothing : (x*Δα÷g)%r
        end
        # Вызов функции и получение результата
        x = ρ(p,a,b,r)
        # Вывод результата
        println(x===nothing ? "Нет решений" : "x = $x")
    # Обработка ошибок при некорректном вводе
    catch
        println("Ошибка: введите 4 числа или 'выход'")
    end
end
# Сообщение о завершении программы
println("Программа завершена")
```

:::
::: {.column width="25%"}

<img width="632" height="852" alt="Снимок экрана 2025-12-02 115242" src="https://github.com/user-attachments/assets/e4c2553a-5c22-4bef-b66f-735e9eb39aee" />

:::
::: {.column width="25%"}

<img width="688" height="387" alt="Снимок экрана 2025-12-02 115112" src="https://github.com/user-attachments/assets/d892b083-1773-4e2e-b93e-73c2ce2d5233" />


:::
::::::::::::::

# Результаты

- Выполнены все необходимые действия для реализации задач лабораторной работы №7: успешно реализовано на языке программирования Julia  дискретное логарифмирование в конечном поле: ρ-алгоритма Полларда для задач дискретного логарифмирования.
## Вывод

Реализовано на языке программирования Julia дискретное логарифмирование в конечном поле: ρ-алгоритма Полларда для задач дискретного логарифмирования.
